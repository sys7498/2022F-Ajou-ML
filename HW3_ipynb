{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/sys7498/2022F-Ajou-ML/blob/main/HW3_ipynb\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "m1rbIpJvJD_m"
      },
      "source": [
        "# **HW3 :: Parameter Tuning and Classifcation**"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "6c34x6aJI_kE"
      },
      "source": [
        "## 코랩과 구글 드라이브 연동 OR 로컬에서 파일 업로드\n",
        "- 해당 섹션 코드 수정 가능"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {
        "id": "PLXjmIbsJMlk"
      },
      "outputs": [],
      "source": [
        "# 연동 OR 파일 업로드\n",
        "# 연동 시 path 설정 주의"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {
        "id": "4VXRY6hDJ60i",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "1c6b2eee-5872-458d-904d-8e50ef143211"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n",
            "/bin/bash: line 0: cd: /drive/MyDrive/ColabNotebooks: No such file or directory\n"
          ]
        }
      ],
      "source": [
        "from google.colab import drive\n",
        "drive.mount('/content/drive')\n",
        "!cd /drive/MyDrive/ColabNotebooks\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "HR6Kw9YhJV8A"
      },
      "source": [
        "## 데이터 불러오기"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 3,
      "metadata": {
        "id": "29BsCuUtKjKA"
      },
      "outputs": [],
      "source": [
        "import numpy as np\n",
        "import pandas as pd"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 4,
      "metadata": {
        "id": "e6BsnGgg4Zle"
      },
      "outputs": [],
      "source": [
        "df = pd.read_csv('drive/MyDrive/ColabNotebooks/airline_sampled2.csv') \n",
        "# HW1에서 사용한 데이터를 샘플링한 파일이므로 꼭 제공된 csv 파일을 사용할 것"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 5,
      "metadata": {
        "id": "XyXXUUUv4Zlf",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "outputId": "5038a265-1e72-4588-d5bd-425aba926bb6"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "   Unnamed: 0  Unnamed: 0.1  Gender  Customer Type  Age  Type of Travel  \\\n",
              "0        8827          8858       0              1   27               1   \n",
              "1        3588          3601       1              0   22               1   \n",
              "2        1011          1017       0              0   23               1   \n",
              "3        7212          7237       1              0   21               1   \n",
              "4        5025          5044       1              1   67               0   \n",
              "\n",
              "   Class  Flight Distance  Inflight wifi service  \\\n",
              "0      2              183                      4   \n",
              "1      0              829                      2   \n",
              "2      2             1020                      4   \n",
              "3      0             1028                      4   \n",
              "4      0              626                      3   \n",
              "\n",
              "   Departure/Arrival time convenient  ...  Inflight entertainment  \\\n",
              "0                                  4  ...                       5   \n",
              "1                                  3  ...                       1   \n",
              "2                                  5  ...                       4   \n",
              "3                                  4  ...                       3   \n",
              "4                                  4  ...                       2   \n",
              "\n",
              "   On-board service  Leg room service  Baggage handling  Checkin service  \\\n",
              "0                 4                 3                 4                3   \n",
              "1                 1                 3                 3                3   \n",
              "2                 3                 4                 5                3   \n",
              "3                 3                 3                 2                5   \n",
              "4                 2                 3                 2                5   \n",
              "\n",
              "   Inflight service  Cleanliness  Departure Delay in Minutes  \\\n",
              "0                 4            5                           0   \n",
              "1                 3            1                           4   \n",
              "2                 5            4                           0   \n",
              "3                 4            3                           0   \n",
              "4                 2            3                           0   \n",
              "\n",
              "   Arrival Delay in Minutes  satisfaction  \n",
              "0                       7.0             0  \n",
              "1                       4.0             0  \n",
              "2                       0.0             1  \n",
              "3                       0.0             1  \n",
              "4                       0.0             0  \n",
              "\n",
              "[5 rows x 25 columns]"
            ],
            "text/html": [
              "\n",
              "  <div id=\"df-31610e27-5000-48b7-b1d5-0ee8ee7d22e0\">\n",
              "    <div class=\"colab-df-container\">\n",
              "      <div>\n",
              "<style scoped>\n",
              "    .dataframe tbody tr th:only-of-type {\n",
              "        vertical-align: middle;\n",
              "    }\n",
              "\n",
              "    .dataframe tbody tr th {\n",
              "        vertical-align: top;\n",
              "    }\n",
              "\n",
              "    .dataframe thead th {\n",
              "        text-align: right;\n",
              "    }\n",
              "</style>\n",
              "<table border=\"1\" class=\"dataframe\">\n",
              "  <thead>\n",
              "    <tr style=\"text-align: right;\">\n",
              "      <th></th>\n",
              "      <th>Unnamed: 0</th>\n",
              "      <th>Unnamed: 0.1</th>\n",
              "      <th>Gender</th>\n",
              "      <th>Customer Type</th>\n",
              "      <th>Age</th>\n",
              "      <th>Type of Travel</th>\n",
              "      <th>Class</th>\n",
              "      <th>Flight Distance</th>\n",
              "      <th>Inflight wifi service</th>\n",
              "      <th>Departure/Arrival time convenient</th>\n",
              "      <th>...</th>\n",
              "      <th>Inflight entertainment</th>\n",
              "      <th>On-board service</th>\n",
              "      <th>Leg room service</th>\n",
              "      <th>Baggage handling</th>\n",
              "      <th>Checkin service</th>\n",
              "      <th>Inflight service</th>\n",
              "      <th>Cleanliness</th>\n",
              "      <th>Departure Delay in Minutes</th>\n",
              "      <th>Arrival Delay in Minutes</th>\n",
              "      <th>satisfaction</th>\n",
              "    </tr>\n",
              "  </thead>\n",
              "  <tbody>\n",
              "    <tr>\n",
              "      <th>0</th>\n",
              "      <td>8827</td>\n",
              "      <td>8858</td>\n",
              "      <td>0</td>\n",
              "      <td>1</td>\n",
              "      <td>27</td>\n",
              "      <td>1</td>\n",
              "      <td>2</td>\n",
              "      <td>183</td>\n",
              "      <td>4</td>\n",
              "      <td>4</td>\n",
              "      <td>...</td>\n",
              "      <td>5</td>\n",
              "      <td>4</td>\n",
              "      <td>3</td>\n",
              "      <td>4</td>\n",
              "      <td>3</td>\n",
              "      <td>4</td>\n",
              "      <td>5</td>\n",
              "      <td>0</td>\n",
              "      <td>7.0</td>\n",
              "      <td>0</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>1</th>\n",
              "      <td>3588</td>\n",
              "      <td>3601</td>\n",
              "      <td>1</td>\n",
              "      <td>0</td>\n",
              "      <td>22</td>\n",
              "      <td>1</td>\n",
              "      <td>0</td>\n",
              "      <td>829</td>\n",
              "      <td>2</td>\n",
              "      <td>3</td>\n",
              "      <td>...</td>\n",
              "      <td>1</td>\n",
              "      <td>1</td>\n",
              "      <td>3</td>\n",
              "      <td>3</td>\n",
              "      <td>3</td>\n",
              "      <td>3</td>\n",
              "      <td>1</td>\n",
              "      <td>4</td>\n",
              "      <td>4.0</td>\n",
              "      <td>0</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>2</th>\n",
              "      <td>1011</td>\n",
              "      <td>1017</td>\n",
              "      <td>0</td>\n",
              "      <td>0</td>\n",
              "      <td>23</td>\n",
              "      <td>1</td>\n",
              "      <td>2</td>\n",
              "      <td>1020</td>\n",
              "      <td>4</td>\n",
              "      <td>5</td>\n",
              "      <td>...</td>\n",
              "      <td>4</td>\n",
              "      <td>3</td>\n",
              "      <td>4</td>\n",
              "      <td>5</td>\n",
              "      <td>3</td>\n",
              "      <td>5</td>\n",
              "      <td>4</td>\n",
              "      <td>0</td>\n",
              "      <td>0.0</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>3</th>\n",
              "      <td>7212</td>\n",
              "      <td>7237</td>\n",
              "      <td>1</td>\n",
              "      <td>0</td>\n",
              "      <td>21</td>\n",
              "      <td>1</td>\n",
              "      <td>0</td>\n",
              "      <td>1028</td>\n",
              "      <td>4</td>\n",
              "      <td>4</td>\n",
              "      <td>...</td>\n",
              "      <td>3</td>\n",
              "      <td>3</td>\n",
              "      <td>3</td>\n",
              "      <td>2</td>\n",
              "      <td>5</td>\n",
              "      <td>4</td>\n",
              "      <td>3</td>\n",
              "      <td>0</td>\n",
              "      <td>0.0</td>\n",
              "      <td>1</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>4</th>\n",
              "      <td>5025</td>\n",
              "      <td>5044</td>\n",
              "      <td>1</td>\n",
              "      <td>1</td>\n",
              "      <td>67</td>\n",
              "      <td>0</td>\n",
              "      <td>0</td>\n",
              "      <td>626</td>\n",
              "      <td>3</td>\n",
              "      <td>4</td>\n",
              "      <td>...</td>\n",
              "      <td>2</td>\n",
              "      <td>2</td>\n",
              "      <td>3</td>\n",
              "      <td>2</td>\n",
              "      <td>5</td>\n",
              "      <td>2</td>\n",
              "      <td>3</td>\n",
              "      <td>0</td>\n",
              "      <td>0.0</td>\n",
              "      <td>0</td>\n",
              "    </tr>\n",
              "  </tbody>\n",
              "</table>\n",
              "<p>5 rows × 25 columns</p>\n",
              "</div>\n",
              "      <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-31610e27-5000-48b7-b1d5-0ee8ee7d22e0')\"\n",
              "              title=\"Convert this dataframe to an interactive table.\"\n",
              "              style=\"display:none;\">\n",
              "        \n",
              "  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n",
              "       width=\"24px\">\n",
              "    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n",
              "    <path d=\"M18.56 5.44l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94zm-11 1L8.5 8.5l.94-2.06 2.06-.94-2.06-.94L8.5 2.5l-.94 2.06-2.06.94zm10 10l.94 2.06.94-2.06 2.06-.94-2.06-.94-.94-2.06-.94 2.06-2.06.94z\"/><path d=\"M17.41 7.96l-1.37-1.37c-.4-.4-.92-.59-1.43-.59-.52 0-1.04.2-1.43.59L10.3 9.45l-7.72 7.72c-.78.78-.78 2.05 0 2.83L4 21.41c.39.39.9.59 1.41.59.51 0 1.02-.2 1.41-.59l7.78-7.78 2.81-2.81c.8-.78.8-2.07 0-2.86zM5.41 20L4 18.59l7.72-7.72 1.47 1.35L5.41 20z\"/>\n",
              "  </svg>\n",
              "      </button>\n",
              "      \n",
              "  <style>\n",
              "    .colab-df-container {\n",
              "      display:flex;\n",
              "      flex-wrap:wrap;\n",
              "      gap: 12px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert {\n",
              "      background-color: #E8F0FE;\n",
              "      border: none;\n",
              "      border-radius: 50%;\n",
              "      cursor: pointer;\n",
              "      display: none;\n",
              "      fill: #1967D2;\n",
              "      height: 32px;\n",
              "      padding: 0 0 0 0;\n",
              "      width: 32px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert:hover {\n",
              "      background-color: #E2EBFA;\n",
              "      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "      fill: #174EA6;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert {\n",
              "      background-color: #3B4455;\n",
              "      fill: #D2E3FC;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert:hover {\n",
              "      background-color: #434B5C;\n",
              "      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n",
              "      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n",
              "      fill: #FFFFFF;\n",
              "    }\n",
              "  </style>\n",
              "\n",
              "      <script>\n",
              "        const buttonEl =\n",
              "          document.querySelector('#df-31610e27-5000-48b7-b1d5-0ee8ee7d22e0 button.colab-df-convert');\n",
              "        buttonEl.style.display =\n",
              "          google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "\n",
              "        async function convertToInteractive(key) {\n",
              "          const element = document.querySelector('#df-31610e27-5000-48b7-b1d5-0ee8ee7d22e0');\n",
              "          const dataTable =\n",
              "            await google.colab.kernel.invokeFunction('convertToInteractive',\n",
              "                                                     [key], {});\n",
              "          if (!dataTable) return;\n",
              "\n",
              "          const docLinkHtml = 'Like what you see? Visit the ' +\n",
              "            '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n",
              "            + ' to learn more about interactive tables.';\n",
              "          element.innerHTML = '';\n",
              "          dataTable['output_type'] = 'display_data';\n",
              "          await google.colab.output.renderOutput(dataTable, element);\n",
              "          const docLink = document.createElement('div');\n",
              "          docLink.innerHTML = docLinkHtml;\n",
              "          element.appendChild(docLink);\n",
              "        }\n",
              "      </script>\n",
              "    </div>\n",
              "  </div>\n",
              "  "
            ]
          },
          "metadata": {},
          "execution_count": 5
        }
      ],
      "source": [
        "df.head()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "fZDTxR6wKuPO"
      },
      "source": [
        "## 데이터 나누기"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "h5enxbYKbAhW"
      },
      "source": [
        "### **주의 사항**\n",
        "train_test_split에 random seed를 사용하여 split set을 고정한다.\n",
        "- 모든 문제에 같은 random seed를 부여할 필요는 없다.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 66,
      "metadata": {
        "id": "V1zQHUKdKWFz",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "2a65f150-302b-4307-a31f-cce14ad4daff"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "0      0\n",
            "1      0\n",
            "2      1\n",
            "3      1\n",
            "4      0\n",
            "      ..\n",
            "995    1\n",
            "996    1\n",
            "997    0\n",
            "998    1\n",
            "999    0\n",
            "Name: satisfaction, Length: 1000, dtype: int64\n",
            "X_train's shape :  (800, 24)\n",
            "y_train's shape :  (800,)\n",
            "\n",
            "X_val's shape :  (100, 24)\n",
            "y_val's shape :  (100,)\n",
            "\n",
            "X_test's shape :  (100, 24)\n",
            "y_test's shape :  (100,)\n"
          ]
        }
      ],
      "source": [
        "from sklearn.model_selection import train_test_split\n",
        "\n",
        "X = df.drop('satisfaction', axis=1)\n",
        "y = df['satisfaction']\n",
        "y=y.astype('int')\n",
        "  \n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1)\n",
        "X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=1/9)\n",
        "\n",
        "print(\"X_train's shape : \", X_train.shape)\n",
        "print(\"y_train's shape : \", y_train.shape)\n",
        "print(\"\\nX_val's shape : \", X_val.shape)\n",
        "print(\"y_val's shape : \", y_val.shape)\n",
        "print(\"\\nX_test's shape : \", X_test.shape)\n",
        "print(\"y_test's shape : \", y_test.shape)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "P5Gr-LZOLCSP"
      },
      "source": [
        "## 문제1 KNN\n",
        "\n",
        "\n",
        "\n",
        "- Scikit-learn 라이브러리를 이용하여 KNN의 최적의 파라미터를 찾는다.\n",
        "    - 최근접 이웃을 찾기 위한 거리의 종류로 최소한 두 가지 이상의 거리 척도를 사용한다.\n",
        "    - K값을 최소 3개 이상 비교한다.\n",
        "    - 거리 척도, k값에 따라 train, validation 정확도를 한 그래프로 그린다.(x축 k값, y축 정확도)\n",
        "    - 찾은 최적의 파라미터와 test set 이용하여 test_accuracy 계산하고 기입한다.\n",
        "    - 최적의 파라미터를 찾은 것에 대한 설명을 '텍스트 셀'에 작성한다.\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 13,
      "metadata": {
        "id": "vVbdK0ERLSq6"
      },
      "outputs": [],
      "source": [
        "from sklearn.neighbors import KNeighborsClassifier\n",
        "from sklearn import metrics\n",
        "import matplotlib.pyplot as plt"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 14,
      "metadata": {
        "id": "ME76ne9cdSMa",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "outputId": "8ab73230-5cd7-4c59-b4fe-e826d5ef41ad"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "0.52\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 432x288 with 1 Axes>"
            ],
            "image/png": "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\n"
          },
          "metadata": {
            "needs_background": "light"
          }
        }
      ],
      "source": [
        "### 문제 1 ###\n",
        "KNN = [1, 3, 5, 7, 9, 11, 13, 15]\n",
        "trainA_acc = []\n",
        "valA_acc = []\n",
        "trainB_acc = []\n",
        "valB_acc = []\n",
        "for k in KNN:\n",
        "  modelA = KNeighborsClassifier(n_neighbors=k, p=1, metric='minkowski')\n",
        "  modelB = KNeighborsClassifier(n_neighbors=k, p=2, metric='minkowski')\n",
        "  modelA.fit(X_train, y_train)\n",
        "  modelB.fit(X_train, y_train)\n",
        "  trainA_acc.append(metrics.accuracy_score(y_train, modelA.predict(X_train)))\n",
        "  trainB_acc.append(metrics.accuracy_score(y_train, modelA.predict(X_train)))\n",
        "  \n",
        "  modelA = KNeighborsClassifier(n_neighbors=k, p=1, metric='minkowski')\n",
        "  modelB = KNeighborsClassifier(n_neighbors=k, p=2, metric='minkowski')\n",
        "  modelA.fit(X_val, y_val)\n",
        "  modelB.fit(X_val, y_val)\n",
        "  valA_acc.append(metrics.accuracy_score(y_val, modelA.predict(X_val)))\n",
        "  valB_acc.append(metrics.accuracy_score(y_val, modelA.predict(X_val)))\n",
        "  \n",
        "plt.figure()\n",
        "plt.plot(KNN, valA_acc, label='valA accuracy')\n",
        "plt.plot(KNN, trainA_acc, label='trainA accuracy')\n",
        "plt.plot(KNN, valB_acc, label='valB accuracy')\n",
        "plt.plot(KNN, trainB_acc, label='trainB accuracy')\n",
        "plt.xlabel('K')\n",
        "plt.ylabel('accuracy')\n",
        "plt.legend()\n",
        "\n",
        "modelA = KNeighborsClassifier(n_neighbors=3, p=1, metric='minkowski')\n",
        "modelA.fit(X_train, y_train)\n",
        "print(metrics.accuracy_score(y_test, modelA.predict(X_test)))\n",
        "\n",
        "### 코드 작성 ###"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "8-BMEqCFdfsR"
      },
      "source": [
        "**설명 작성**  \n",
        "- 최적의 파라미터: 거리 = 맨하탄, 거리k = 3\n",
        "- 설명: X축은 k값, Y축은 정확도, 주황색은 맨하탄 거리일때 KNN알고리즘, 파란색은 유클라디안 거리일때 KNN알고리즘입니다. K=3일때 맨하탄 거리인 KNN알고리즘의 정확도가 제일 높은 것을 알 수 있습니다. 그러므로 최적의 하이퍼파라미터는 맨하탄거리, k = 3이라고 결정하였습니다."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "mZkD2D1i4Zli"
      },
      "source": [
        "---"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "7OMvtg924Zli"
      },
      "source": [
        "## 문제2 Random Forest\n",
        "\n",
        "\n",
        "- Scikit-learn 라이브러리를 이용하여 Random Forest의 최적의 파라미터를 찾는다.\n",
        "    - Criterion 중 최소 두개를 비교한다.\n",
        "    - 최적의 파라미터 max depth 값을 찾는다.\n",
        "    - 파라미터에 따라 train, validation 정확도를 한 그래프로 그린다.(x축 max depth 값, y축 정확도)\n",
        "    - 찾은 최적의 파라미터와 test set을 이용하여 test accuracy를 계산하고 기입한다.\n",
        "    - 최적의 파라미터를 찾은 것에 대한 설명을 '텍스트 셀'에 작성한다."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 15,
      "metadata": {
        "id": "IttBH6C94Zli"
      },
      "outputs": [],
      "source": [
        "from sklearn.ensemble import RandomForestClassifier"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 17,
      "metadata": {
        "id": "C153cWxK4Zli",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "outputId": "b6f62279-c3bf-497c-8220-9e2291a72ea7"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "0.87\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 432x288 with 1 Axes>"
            ],
            "image/png": "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\n"
          },
          "metadata": {
            "needs_background": "light"
          }
        }
      ],
      "source": [
        "### 문제 2 ###\n",
        "K = [5, 10, 50, 100]\n",
        "trainRF = []\n",
        "valRF = []\n",
        "for k in K:\n",
        "  modelRFA = RandomForestClassifier(max_depth=k)\n",
        "  modelRFA.fit(X_train, y_train)\n",
        "  trainRF.append(metrics.accuracy_score(y_train, modelRFA.predict(X_train)))\n",
        "  valRF.append(metrics.accuracy_score(y_val, modelRFA.predict(X_val)))\n",
        "  \n",
        "plt.figure()\n",
        "plt.plot(K, valRF, label='val accuracy')\n",
        "plt.plot(K, trainRF, label='train accuracy')\n",
        "plt.xlabel('depth')\n",
        "plt.ylabel('accuracy')\n",
        "plt.legend()\n",
        "\n",
        "modelRFA = RandomForestClassifier(max_depth=50)\n",
        "modelRFA.fit(X_train, y_train)\n",
        "print(metrics.accuracy_score(y_test, modelRFA.predict(X_test)))\n",
        "\n",
        "### 코드 작성 ###"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "s4r40Dbu4Zli"
      },
      "source": [
        "**설명 작성**  \n",
        "- 최적의 파라미터: max_depth = 50\n",
        "- 설명: train 정확도는 10일때부터 1에 가까운 값을 계속 내고있지만, validation accuracy는 50일때 거의 최고치를 달성하고, 그 이후 다시 떨어지고있는 것을 확인 할 수 있습니다. 또한, 너무 깊이 들어가게 되면 overfit하기 때문에 50 정도가 제일적당한 값이라고 생각했습니다."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "KvjjbqDB4Zli"
      },
      "source": [
        "---"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "cl1b3f3AaZUw"
      },
      "source": [
        "## 문제3 Cross validation with Linear SVM\n",
        "### 3-1: k-fold\n",
        "- 수업시간에 배운 **5-fold** 를 이용하여 최적의 파라미터를 찾는다. (데이터는 동일)\n",
        "- 수업시간에 배운 linear SVM 모델의 파라미터 C를 cross-validation을 바탕으로 최적화한다.\n",
        "    - **5-fold CV를 할 때, test data를 제외한 90%의 데이터를 사용해야한다.**\n",
        "    - 파라미터에 따라 K-fold CV를 통해 나온 평균 정확도와 각 fold의 정확도들을 한 그래프로 그린다.(x축 선택한 파라미터, y축 정확도)\n",
        "    - 찾은 최적의 파라미터와 test set을 이용하여 test accuracy를 계산하고 기입한다.\n",
        "    - 최적의 파라미터를 찾은 것에 대한 설명을 '텍스트 셀'에 작성한다.\n",
        "\n",
        "### 3-2: Leave One Out\n",
        "- 수업시간에 배운 Leave-One-Out 를 이용하여 최적의 파라미터를 찾는다. (데이터는 동일)\n",
        "- 수업시간에 배운 linear SVM 모델의 파라미터 C를 cross-validation을 바탕으로 최적화한다.\n",
        "  - **Leave-One-Out CV를 할 때, test data를 제외한 90%의 데이터를 사용해야한다.**\n",
        "  - 파라미터에 따라 Leave-One-Out CV를 통해 나온 평균 정확도를 그래프로 그린다.(x축 선택한 파라미터, y축 정확도)\n",
        "  - 찾은 최적의 파라미터와 test set을 이용하여 test accuracy를 계산하고 기입한다.\n",
        "  - 최적의 파라미터를 찾은 것에 대한 설명을 '텍스트 셀'에 작성한다."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 124,
      "metadata": {
        "id": "fYNny36efEF3",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 398
        },
        "outputId": "adf82fb3-219f-4d53-b34e-f90d143a860e"
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "KeyboardInterrupt",
          "evalue": "ignored",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
            "\u001b[0;32m<ipython-input-124-e021302ae648>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     37\u001b[0m     \u001b[0mX_test_scaled\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mscaler\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfit_transform\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_test\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     38\u001b[0m     \u001b[0mmodelKSVM\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mSVC\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mC\u001b[0m\u001b[0;34m=\u001b[0m \u001b[0mc\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkernel\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m'linear'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 39\u001b[0;31m     \u001b[0mmodelKSVM\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtrainx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtrainy\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     40\u001b[0m     \u001b[0mkfold_acc\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mcnumber\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmetrics\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0maccuracy_score\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mvaly\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmodelKSVM\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpredict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mvalx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     41\u001b[0m     \u001b[0mkfold_acc_test\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mcnumber\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmetrics\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0maccuracy_score\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0my_test\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmodelKSVM\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpredict\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_test\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.7/dist-packages/sklearn/svm/_base.py\u001b[0m in \u001b[0;36mfit\u001b[0;34m(self, X, y, sample_weight)\u001b[0m\n\u001b[1;32m    253\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    254\u001b[0m         \u001b[0mseed\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mrnd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrandint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0miinfo\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"i\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmax\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 255\u001b[0;31m         \u001b[0mfit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msample_weight\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msolver_type\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkernel\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrandom_seed\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mseed\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    256\u001b[0m         \u001b[0;31m# see comment on the other call to np.iinfo in this file\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    257\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.7/dist-packages/sklearn/svm/_base.py\u001b[0m in \u001b[0;36m_dense_fit\u001b[0;34m(self, X, y, sample_weight, solver_type, kernel, random_seed)\u001b[0m\n\u001b[1;32m    331\u001b[0m             \u001b[0mepsilon\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mepsilon\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    332\u001b[0m             \u001b[0mmax_iter\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmax_iter\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 333\u001b[0;31m             \u001b[0mrandom_seed\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mrandom_seed\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    334\u001b[0m         )\n\u001b[1;32m    335\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
          ]
        }
      ],
      "source": [
        "### 문제 3-1 ###\n",
        "from sklearn.model_selection import KFold\n",
        "from sklearn.svm import SVC\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "scaler = StandardScaler()\n",
        "tX = pd.concat([X_train, X_val])\n",
        "tY = pd.concat([y_train, y_val])\n",
        "kfold = KFold(n_splits=5)\n",
        "kfold_acc = [[],[],[],[],[], []]\n",
        "kfold_acc_byC = []\n",
        "kfold_acc_test = [[],[],[],[],[],[]]\n",
        "kfold_acc_test_byC = []\n",
        "CA = [0.0001, 0.001, 0.1, 1,2, 3]\n",
        "cnumber = 0\n",
        "\n",
        "'''for c in CA:\n",
        "  for trainIdx, valIdx in kfold.split(tX, tY):\n",
        "    trainx, valx = tX.iloc[trainIdx], tX.iloc[valIdx]\n",
        "    trainy, valy = tY.iloc[trainIdx], tY.iloc[valIdx]\n",
        "    X_train_scaled = scaler.fit_transform(trainx)\n",
        "    X_val_scaled = scaler.fit_transform(valx)\n",
        "    X_test_scaled = scaler.fit_transform(X_test)\n",
        "    modelKSVM = SVC(C= c, kernel = 'linear')\n",
        "    modelKSVM.fit(X_train_scaled, trainy)\n",
        "    kfold_acc[cnumber].append(metrics.accuracy_score(valy, modelKSVM.predict(X_val_scaled)))\n",
        "    kfold_acc_test[cnumber].append(metrics.accuracy_score(y_test, modelKSVM.predict(X_test_scaled)))\n",
        "  kfold_acc_byC.append(np.mean(kfold_acc[cnumber]))\n",
        "  kfold_acc_test_byC.append(np.mean(kfold_acc_test[cnumber]))\n",
        "  cnumber += 1'''\n",
        "\n",
        "for c in CA:\n",
        "  for trainIdx, valIdx in kfold.split(tX, tY):\n",
        "    trainx, valx = tX.iloc[trainIdx], tX.iloc[valIdx]\n",
        "    trainy, valy = tY.iloc[trainIdx], tY.iloc[valIdx]\n",
        "    X_train_scaled = scaler.fit_transform(trainx)\n",
        "    X_val_scaled = scaler.fit_transform(valx)\n",
        "    X_test_scaled = scaler.fit_transform(X_test)\n",
        "    modelKSVM = SVC(C= c, kernel = 'linear')\n",
        "    modelKSVM.fit(trainx, trainy)\n",
        "    kfold_acc[cnumber].append(metrics.accuracy_score(valy, modelKSVM.predict(valx)))\n",
        "    kfold_acc_test[cnumber].append(metrics.accuracy_score(y_test, modelKSVM.predict(X_test)))\n",
        "  kfold_acc_byC.append(np.mean(kfold_acc[cnumber]))\n",
        "  kfold_acc_test_byC.append(np.mean(kfold_acc_test[cnumber]))\n",
        "  cnumber += 1\n",
        "\n",
        "plt.figure()\n",
        "plt.plot(CA, kfold_acc_byC, label='kfold accuracy_byc')\n",
        "plt.xlabel('c')\n",
        "plt.ylabel('accuracy')\n",
        "plt.legend()\n",
        "print(\"best C number = \", CA[np.argmax(kfold_acc_byC)])\n",
        "print(\"test accuracy = \", kfold_acc_test_byC[np.argmax(kfold_acc_byC)])\n",
        "### 코드 작성 ###"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "2xvEdCHAfH0g"
      },
      "source": [
        "**설명 작성**  \n",
        "- 최적의 파라미터: c = 0.1\n",
        "- 설명: c 를 0.0001 부터 10 까지 늘려가며 linear SVM을 통해 학습을 진행, train set과 validation set을 통해 구한 model 각각 test set의 accuracy를 진행 하였습니다. 그 후, validation accuracy의 값이 제일 높은 모델에서의 test accuracy 값을 찾아보았을 때 0.89라는 값이 나왔습니다."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 120,
      "metadata": {
        "id": "80a5iRmvfG6H",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 416
        },
        "outputId": "8a0931cc-efbf-43da-a5b8-7d0f45e307cc"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "900\n"
          ]
        },
        {
          "output_type": "error",
          "ename": "KeyboardInterrupt",
          "evalue": "ignored",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
            "\u001b[0;32m<ipython-input-120-9a6dcc50d488>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     15\u001b[0m     \u001b[0mtrainx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mvalx\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtX\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0miloc\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mtrainIdx\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtX\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0miloc\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mvalIdx\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     16\u001b[0m     \u001b[0mtrainy\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mvaly\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtY\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0miloc\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mtrainIdx\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtY\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0miloc\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mvalIdx\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 17\u001b[0;31m     \u001b[0mX_train_scaled\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mscaler\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfit_transform\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtrainx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     18\u001b[0m     \u001b[0mX_val_scaled\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mscaler\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfit_transform\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mvalx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     19\u001b[0m     \u001b[0mX_test_scaled\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mscaler\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfit_transform\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX_test\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.7/dist-packages/sklearn/base.py\u001b[0m in \u001b[0;36mfit_transform\u001b[0;34m(self, X, y, **fit_params)\u001b[0m\n\u001b[1;32m    850\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0my\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    851\u001b[0m             \u001b[0;31m# fit method of arity 1 (unsupervised transformation)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 852\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mfit_params\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtransform\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    853\u001b[0m         \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    854\u001b[0m             \u001b[0;31m# fit method of arity 2 (supervised transformation)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.7/dist-packages/sklearn/preprocessing/_data.py\u001b[0m in \u001b[0;36mfit\u001b[0;34m(self, X, y, sample_weight)\u001b[0m\n\u001b[1;32m    804\u001b[0m         \u001b[0;31m# Reset internal state before fitting\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    805\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_reset\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 806\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpartial_fit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msample_weight\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    807\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    808\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mpartial_fit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msample_weight\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.7/dist-packages/sklearn/preprocessing/_data.py\u001b[0m in \u001b[0;36mpartial_fit\u001b[0;34m(self, X, y, sample_weight)\u001b[0m\n\u001b[1;32m    845\u001b[0m             \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mFLOAT_DTYPES\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    846\u001b[0m             \u001b[0mforce_all_finite\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"allow-nan\"\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 847\u001b[0;31m             \u001b[0mreset\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mfirst_call\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    848\u001b[0m         )\n\u001b[1;32m    849\u001b[0m         \u001b[0mn_features\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mX\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.7/dist-packages/sklearn/base.py\u001b[0m in \u001b[0;36m_validate_data\u001b[0;34m(self, X, y, reset, validate_separately, **check_params)\u001b[0m\n\u001b[1;32m    564\u001b[0m             \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Validation should be done on X, y or both.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    565\u001b[0m         \u001b[0;32melif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mno_val_X\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mno_val_y\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 566\u001b[0;31m             \u001b[0mX\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcheck_array\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mX\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mcheck_params\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    567\u001b[0m             \u001b[0mout\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mX\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    568\u001b[0m         \u001b[0;32melif\u001b[0m \u001b[0mno_val_X\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mno_val_y\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.7/dist-packages/sklearn/utils/validation.py\u001b[0m in \u001b[0;36mcheck_array\u001b[0;34m(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, estimator)\u001b[0m\n\u001b[1;32m    627\u001b[0m                 )\n\u001b[1;32m    628\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 629\u001b[0;31m         \u001b[0mdtypes_orig\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mlist\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0marray\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdtypes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    630\u001b[0m         \u001b[0;31m# pandas boolean dtype __array__ interface coerces bools to objects\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    631\u001b[0m         \u001b[0;32mfor\u001b[0m \u001b[0mi\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype_iter\u001b[0m \u001b[0;32min\u001b[0m \u001b[0menumerate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdtypes_orig\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.7/dist-packages/pandas/core/generic.py\u001b[0m in \u001b[0;36mdtypes\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m   5657\u001b[0m         \"\"\"\n\u001b[1;32m   5658\u001b[0m         \u001b[0mdata\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_mgr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_dtypes\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 5659\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_constructor_sliced\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mindex\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_info_axis\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mobject_\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   5660\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   5661\u001b[0m     def astype(\n",
            "\u001b[0;32m/usr/local/lib/python3.7/dist-packages/pandas/core/generic.py\u001b[0m in \u001b[0;36m_info_axis\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    631\u001b[0m     \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    632\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_info_axis\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0mIndex\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 633\u001b[0;31m         \u001b[0;32mreturn\u001b[0m \u001b[0mgetattr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_info_axis_name\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    634\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    635\u001b[0m     \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
          ]
        }
      ],
      "source": [
        "### 문제 3-2 ###\n",
        "tX = pd.concat([X_train, X_val])\n",
        "tY = pd.concat([y_train, y_val])\n",
        "print(tX.shape[0])\n",
        "loocv = KFold(n_splits=len(tX))\n",
        "loocv_acc = [[],[],[],[]]\n",
        "loocv_acc_byC = []\n",
        "loocv_acc_test = [[],[],[],[],[]]\n",
        "loocv_acc_test_byC = []\n",
        "\n",
        "CA = [0.001, 0.01, 0.1, 1]\n",
        "cnumber = 0\n",
        "for c in CA:\n",
        "  for trainIdx, valIdx in loocv.split(tX, tY):\n",
        "    trainx, valx = tX.iloc[trainIdx], tX.iloc[valIdx]\n",
        "    trainy, valy = tY.iloc[trainIdx], tY.iloc[valIdx]\n",
        "    X_train_scaled = scaler.fit_transform(trainx)\n",
        "    X_val_scaled = scaler.fit_transform(valx)\n",
        "    X_test_scaled = scaler.fit_transform(X_test)\n",
        "    modelLSVM = SVC(C= c, kernel = 'linear')\n",
        "    modelLSVM.fit(X_train_scaled, trainy)\n",
        "    loocv_acc[cnumber].append(metrics.accuracy_score(valy, modelLSVM.predict(X_val_scaled)))\n",
        "    loocv_acc_test[cnumber].append(metrics.accuracy_score(y_test, modelLSVM.predict(X_test_scaled)))\n",
        "  loocv_acc_byC.append(np.mean(loocv_acc[cnumber]))\n",
        "  loocv_acc_test_byC.append(np.mean(loocv_acc_test[cnumber]))\n",
        "  cnumber += 1\n",
        "\n",
        "plt.figure()\n",
        "plt.plot(CA, loocv_acc_byC, label='loocv accuracy_byc')\n",
        "plt.xlabel('c')\n",
        "plt.ylabel('accuracy')\n",
        "plt.legend()\n",
        "\n",
        "print(\"best C number = \", CA[np.argmax(loocv_acc_byC)])\n",
        "print(\"test accuracy = \", loocv_acc_test_byC[np.argmax(loocv_acc_byC)])\n",
        "### 코드 작성 ###"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "m9BqByTFfLIG"
      },
      "source": [
        "**설명 작성**  \n",
        "- 최적의 파라미터: c = 0.001\n",
        "- 설명: c 를 0.0001 부터 10 까지 늘려가며 linear SVM을 통해 학습을 진행, train set과 validation set을 통해 구한 model 각각 test set의 accuracy를 진행 하였습니다. 그 후, validation accuracy의 값이 제일 높은 모델에서의 test accuracy 값을 찾아보았을 때 0.849라는 값이 나왔습니다."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "qUzl5Lcz4Zlj"
      },
      "source": [
        "---"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "szX5GgcXfnM1"
      },
      "source": [
        "## 문제4 Regression\n",
        "문제 4 에서는 캘리포니아 주택 가격 데이터셋을 사용합니다.   \n",
        "학습을 통해 주택 가격을 예측하는 문제입니다.  \n",
        "데이터에 대한 자세한 설명은 아래 코드의 description을 참고해주세요."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 108,
      "metadata": {
        "id": "Gwwkd_GO4Zlj",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "788117ba-746e-4790-820b-dae6c797b314"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            ".. _california_housing_dataset:\n",
            "\n",
            "California Housing dataset\n",
            "--------------------------\n",
            "\n",
            "**Data Set Characteristics:**\n",
            "\n",
            "    :Number of Instances: 20640\n",
            "\n",
            "    :Number of Attributes: 8 numeric, predictive attributes and the target\n",
            "\n",
            "    :Attribute Information:\n",
            "        - MedInc        median income in block group\n",
            "        - HouseAge      median house age in block group\n",
            "        - AveRooms      average number of rooms per household\n",
            "        - AveBedrms     average number of bedrooms per household\n",
            "        - Population    block group population\n",
            "        - AveOccup      average number of household members\n",
            "        - Latitude      block group latitude\n",
            "        - Longitude     block group longitude\n",
            "\n",
            "    :Missing Attribute Values: None\n",
            "\n",
            "This dataset was obtained from the StatLib repository.\n",
            "https://www.dcc.fc.up.pt/~ltorgo/Regression/cal_housing.html\n",
            "\n",
            "The target variable is the median house value for California districts,\n",
            "expressed in hundreds of thousands of dollars ($100,000).\n",
            "\n",
            "This dataset was derived from the 1990 U.S. census, using one row per census\n",
            "block group. A block group is the smallest geographical unit for which the U.S.\n",
            "Census Bureau publishes sample data (a block group typically has a population\n",
            "of 600 to 3,000 people).\n",
            "\n",
            "An household is a group of people residing within a home. Since the average\n",
            "number of rooms and bedrooms in this dataset are provided per household, these\n",
            "columns may take surpinsingly large values for block groups with few households\n",
            "and many empty houses, such as vacation resorts.\n",
            "\n",
            "It can be downloaded/loaded using the\n",
            ":func:`sklearn.datasets.fetch_california_housing` function.\n",
            "\n",
            ".. topic:: References\n",
            "\n",
            "    - Pace, R. Kelley and Ronald Barry, Sparse Spatial Autoregressions,\n",
            "      Statistics and Probability Letters, 33 (1997) 291-297\n",
            "\n"
          ]
        }
      ],
      "source": [
        "from sklearn.datasets import fetch_california_housing\n",
        "housing = fetch_california_housing()\n",
        "print(housing.DESCR)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 109,
      "metadata": {
        "id": "beqDbNzQi0PR"
      },
      "outputs": [],
      "source": [
        "df = pd.DataFrame(housing.data, columns=housing.feature_names)\n",
        "df['target'] = housing.target"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 110,
      "metadata": {
        "id": "Y-4fgqWCkd-o",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "0a182252-1faa-4ad1-a237-19e0c8468315"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "   MedInc  HouseAge  AveRooms  AveBedrms  Population  AveOccup  Latitude  \\\n",
            "0  8.3252      41.0  6.984127   1.023810       322.0  2.555556     37.88   \n",
            "1  8.3014      21.0  6.238137   0.971880      2401.0  2.109842     37.86   \n",
            "2  7.2574      52.0  8.288136   1.073446       496.0  2.802260     37.85   \n",
            "3  5.6431      52.0  5.817352   1.073059       558.0  2.547945     37.85   \n",
            "4  3.8462      52.0  6.281853   1.081081       565.0  2.181467     37.85   \n",
            "\n",
            "   Longitude  target  \n",
            "0    -122.23   4.526  \n",
            "1    -122.22   3.585  \n",
            "2    -122.24   3.521  \n",
            "3    -122.25   3.413  \n",
            "4    -122.25   3.422  \n"
          ]
        }
      ],
      "source": [
        "print(df.head())"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 111,
      "metadata": {
        "id": "zoUn3ZXdkimJ",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "43059c4e-533e-4280-9aff-fc93aca277e9"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "(20640, 9)\n",
            "             MedInc      HouseAge      AveRooms     AveBedrms    Population  \\\n",
            "count  20640.000000  20640.000000  20640.000000  20640.000000  20640.000000   \n",
            "mean       3.870671     28.639486      5.429000      1.096675   1425.476744   \n",
            "std        1.899822     12.585558      2.474173      0.473911   1132.462122   \n",
            "min        0.499900      1.000000      0.846154      0.333333      3.000000   \n",
            "25%        2.563400     18.000000      4.440716      1.006079    787.000000   \n",
            "50%        3.534800     29.000000      5.229129      1.048780   1166.000000   \n",
            "75%        4.743250     37.000000      6.052381      1.099526   1725.000000   \n",
            "max       15.000100     52.000000    141.909091     34.066667  35682.000000   \n",
            "\n",
            "           AveOccup      Latitude     Longitude        target  \n",
            "count  20640.000000  20640.000000  20640.000000  20640.000000  \n",
            "mean       3.070655     35.631861   -119.569704      2.068558  \n",
            "std       10.386050      2.135952      2.003532      1.153956  \n",
            "min        0.692308     32.540000   -124.350000      0.149990  \n",
            "25%        2.429741     33.930000   -121.800000      1.196000  \n",
            "50%        2.818116     34.260000   -118.490000      1.797000  \n",
            "75%        3.282261     37.710000   -118.010000      2.647250  \n",
            "max     1243.333333     41.950000   -114.310000      5.000010  \n"
          ]
        }
      ],
      "source": [
        "print(df.shape) #(20640, 9)\n",
        "print(df.describe())"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "3U8somVc4Zlk"
      },
      "source": [
        "### 문제 4-1 : Adjusted R2 Score\n",
        "- sklearn.metrics 패키지를 사용하여 ```def adjr2```에 Adjusted R2 Score를 구하는 함수를 작성한다.\n",
        "- ```def r2```를 사용하여 ```adjr2```를 구현한다.\n",
        "- 코드 작성 영역 이외의 코드를 수정하지 않는다.\n",
        "- 주어진 함수 파라미터를 사용하여 구현한다."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 112,
      "metadata": {
        "id": "JbGUADBK4Zlk"
      },
      "outputs": [],
      "source": [
        "from sklearn.metrics import r2_score"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 125,
      "metadata": {
        "id": "WvqWUQl24Zlk"
      },
      "outputs": [],
      "source": [
        "import numpy as np\n",
        "\n",
        "def r2(actual, predicted):\n",
        "    \"\"\" R2 Score \"\"\"\n",
        "    return r2_score(actual, predicted)\n",
        "\n",
        "###################################\n",
        "def adjr2(actual, predicted, rowcount, featurecount):\n",
        "############ 문제 4-1 ##############\n",
        "    \"\"\" Adjusted R2 Score \"\"\"\n",
        "    return (1-(1-r2(actual, predicted)) * (len(actual)-1) / (len(predicted) - featurecount - 1))\n",
        "####################################\n",
        "####################################"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "P-6ZikyP4Zlk"
      },
      "source": [
        "### 문제 4-2 : Feature Selection\n",
        "- sklearn 패키지를 사용하여 feature selection을 수행하는 함수 ```forward_selection```을 구현한다.\n",
        "- Linear Regressor 을 사용하여 feature selection이 어떻게 달라지는 지 관찰한다.\n",
        "- 코드 작성 영역 이외의 코드를 수정하지 않는다.\n",
        "- 주어진 변수들, 자료들을 최대한 활용하여 코드를 작성한다."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 126,
      "metadata": {
        "id": "WjqDsXSA4Zlk"
      },
      "outputs": [],
      "source": [
        "from sklearn.linear_model import LinearRegression\n",
        "import pandas as pd"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 155,
      "metadata": {
        "id": "oUf_G0iF4Zlk",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "c523dedf-8e9e-4eb4-99b8-33f371d2ef70"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "(20640, 8)\n",
            "(20640,)\n"
          ]
        }
      ],
      "source": [
        "X = df.drop(columns=['target'])\n",
        "y = df['target']\n",
        "y=y.astype('int')\n",
        "print(X.shape)\n",
        "print(y.shape)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 161,
      "metadata": {
        "collapsed": true,
        "id": "tAQiA64x4Zlk",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "3cdf6afa-2380-48be-94b3-75bdfea2a22f"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "selected_features: ['MedInc', 'HouseAge', 'Latitude', 'Longitude', 'AveBedrms', 'AveRooms', 'AveOccup']\n"
          ]
        }
      ],
      "source": [
        "def forward_selection(X, y): # X: train data, y: train data's target\n",
        "    initial_list = []\n",
        "    included = list(initial_list) # 포함되어야 하는 feature\n",
        "    best_r2 = 0 # 가장 높은 r2 score를 저장\n",
        "\n",
        "    while True:\n",
        "\n",
        "        changed = False # while 문을 빠져나가는 조건으로 활용\n",
        "        excluded = list(set(X.columns)-set(included)) # included list에 없는 column names 저장하는 리스트\n",
        "        new_scores = dict.fromkeys(excluded)\n",
        "\n",
        "        for new_column in excluded:\n",
        "            \n",
        "            model = LinearRegression()\n",
        "            \n",
        "\n",
        "            ###########################################\n",
        "            ###### 코드 작성 영역 외 수정 하지 말 것 #########\n",
        "            ################ 문제 4-2 ##################\n",
        "            included.append(new_column) #included에 새로운 feature 추가\n",
        "            model.fit(X[included], y) # 학습\n",
        "            predY = model.predict(X[included]) # 예측\n",
        "            new_scores[new_column] = adjr2(y, predY, len(y), len(included)) # r2 값 new_score dict에 저장장\n",
        "            included.pop() # 넣었던 거 빼기\n",
        "        \n",
        "        \n",
        "        if(max(new_scores.values()) > best_r2): #넣었던 r2중의 최고 r2가 bestr2보다 크다면\n",
        "          included.append(max(new_scores, key=new_scores.get)) # 그 feature 넣고\n",
        "          best_r2 = max(new_scores.values()) # best_r2값 변경\n",
        "          continue \n",
        "        else: # 아니라면\n",
        "          break # 끝\n",
        "        ##############################################\n",
        "        ##############################################\n",
        " \n",
        "    return included\n",
        "\n",
        "selected_features = forward_selection(X, y)\n",
        "print('selected_features:', selected_features)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "0OGUhsrgEwR_"
      },
      "source": [
        "### 문제 4-3: Regularized Model\n",
        "- Scikit-learn 라이브러리를 사용하여 Ridge Regression과 Lasso Regression 모델을 만든다.\n",
        "- train : validation : test **데이터셋의 비율을 8:1:1**로 설정한다.\n",
        "- 문제 4-1의 **forward selection을 통해 얻은 feature만**을 가진 데이터를 사용한다.\n",
        "- 다양한 alpha 값에 대해 validation dataset을 사용하여 각 모델에 대한 **최적의 alpha 값을 찾고 찾은 최적의 alpha 값을 텍스트 셀에 작성**한다.\n",
        "- alpha 값은 아래의 리스트를 사용한다.  \n",
        "```alpha = [0.0001, 0.001,0.01,0.1,1,10, 100, 1000, 10000, 100000]```\n",
        "- alpha 값에 대한 R2 score의 변화를 그래프로 나타낸다.\n",
        "  * **x축: alpha 값**\n",
        "  * **y축: R2 score 값**\n",
        "  * 파란색 선: Ridge 결과, 빨간색 선: Lasso 결과\n",
        "  * 그래프에 **legend**가 포함되어 있어야 한다. \n",
        "- **train과 validation dataset을 합하여 train set을 만든 후 최종 학습 결과를 도출**한다.\n",
        "  * 최적의 alpha 값을 찾을 때 사용한 test set은 변하지 않는다. \n",
        "  * r2 score를 사용하여 train set에 대한 prediction 결과와 test set에 대한 prediction 결과를 구해 print 한다."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 162,
      "metadata": {
        "id": "NEx72fQh4Zll"
      },
      "outputs": [],
      "source": [
        "from sklearn.linear_model import LinearRegression, Ridge, Lasso\n",
        "from sklearn.metrics import r2_score\n",
        "import numpy as np"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 167,
      "metadata": {
        "id": "2ZJbj9r2Z4LP",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "87b96d2b-6bcb-450d-c726-3c882f06de74"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "0.8372476578327066\n",
            "0.8372470695379849\n",
            "0.8372476578327056\n",
            "0.8371892300537516\n",
            "0.837247657832608\n",
            "0.8326194208548724\n",
            "0.8372476578228571\n",
            "0.7820653104638653\n",
            "0.8372476568479885\n",
            "0.0037928941743489153\n",
            "0.8372475595885174\n",
            "0.003396510021565713\n",
            "0.8372380543328902\n",
            "-0.00036352620418056425\n",
            "0.8364582566447573\n",
            "-0.00036352620418056425\n",
            "0.8070852366935006\n",
            "-0.00036352620418056425\n",
            "0.5047548534665605\n",
            "-0.00036352620418056425\n"
          ]
        }
      ],
      "source": [
        "### 문제 4-3 ###\n",
        "X = df.drop('AveBedrms', axis=1)\n",
        "y = df['AveBedrms']\n",
        "\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1)\n",
        "X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=1/9)\n",
        "\n",
        "alpha = [0.0001, 0.001,0.01,0.1,1,10, 100, 1000, 10000, 100000]\n",
        "ridgeR2List = []\n",
        "lassoR2List = []\n",
        "for a in alpha:\n",
        "  ridge = Ridge(alpha = a)\n",
        "  ridge.fit(X_train, y_train)\n",
        "  ridgePredY = ridge.predict(X_train)\n",
        "  ridgeR2 = adjr2(y_train, ridgePredY, len(y_train), 6)\n",
        "  ridgeR2List.append(ridgeR2)\n",
        "  lasso = Lasso(alpha = a)\n",
        "  lasso.fit(X_train, y_train)\n",
        "  lassoPredY = lasso.predict(X_train)\n",
        "  lassoR2 = adjr2(y_train, lassoPredY, len(y_train), 6)\n",
        "  lassoR2List.append(lassoR2)\n",
        "  print(ridgeR2)\n",
        "  print(lassoR2)\n",
        "\n",
        "\n",
        "\n",
        "### 코드 작성 ###"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 170,
      "metadata": {
        "id": "Ym11BIQD4Zll",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 297
        },
        "outputId": "6c4242cf-fe94-40d2-82be-3efdf80cc103"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "<matplotlib.legend.Legend at 0x7f5850597910>"
            ]
          },
          "metadata": {},
          "execution_count": 170
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 432x288 with 1 Axes>"
            ],
            "image/png": "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\n"
          },
          "metadata": {
            "needs_background": "light"
          }
        }
      ],
      "source": [
        "### 문제 4-3 ###\n",
        "plt.figure()\n",
        "plt.plot(alpha, ridgeR2List, label='ridgeR2')\n",
        "plt.plot(alpha, lassoR2List, label='lassoR2')\n",
        "plt.xlabel('alpha')\n",
        "plt.ylabel('R2')\n",
        "plt.legend()\n",
        "### 그래프 작성 ###"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "DS8x1JmkZ6Yl"
      },
      "source": [
        "- Rridge regression 모델 최적의 alpha 값:\n",
        "- Lasso regression 모델 최적의 alpha 값:"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "zio0ZtfdiXCF"
      },
      "outputs": [],
      "source": [
        "# 최종 결과 출력"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "collapsed_sections": [],
      "provenance": [],
      "include_colab_link": true
    },
    "interpreter": {
      "hash": "72f413c705acf8cc7ca758c5c7ce13adba655409ec2684a2da3bcb9a148f4862"
    },
    "kernelspec": {
      "display_name": "Python 3.8.13 ('aae')",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8.13"
    },
    "vscode": {
      "interpreter": {
        "hash": "4df1aae1e0b0d359ea12b19172edf8042a617e338541b2db12efe6535537db04"
      }
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}